import numpyimport mathimport cmath# Calculates f(x) values for x_j nodesfx=[]for i in range(0,8):    fx.append(math.exp(math.sin(i*2*math.pi/8)))#ck values using ifftck=numpy.fft.ifft(fx)#uses formula from #3 to find a_k and b_k coefficientsalist=[2*ck[0],(ck[7]+ck[1]),(ck[6]+ck[2]),(ck[5]+ck[3]),2*ck[4]]       blist=[0,1j*(ck[7]-ck[1]),1j*(ck[6]-ck[2]),1j*(ck[5]-ck[3])]#plugs coefficients into interpolation polynomial formuladef p8(x):    p=(1/2)*alist[0]+(1/2)*alist[4]*math.cos(4*x)    for i in range(1,4):        p+=(alist[i]*math.cos(i*x))+(blist[i]*math.sin(i*x))    return(p)#calculates list of values of p8(x) at each x_j nodep8xlist=[]for i in range (0,9):    p8xlist.append(p8(i*2*math.pi/8))#### PROBLEM 4 #####formula for prime valuesdef p8prime(x):    total=((1/2)*(-4j)*ck[4]*cmath.exp(-4j*x))+((1/2)*(4j)*ck[4]*cmath.exp(4j*x))    for i in range (-3,0):        total+=(i*1j)*ck[8+i]*cmath.exp(i*1j*x)    for i in range(0,4):        total+=(i*1j)*ck[i]*cmath.exp(i*1j*x)    return(total)#calculates list of primes at each x_j nodep8primelist=[]for i in range(0,9):    p8primelist.append(p8prime(i*2*math.pi/8))#the previous formula calculated the result in a different order than f'(x) and I didn't have time to change it so I rearranged the output values in this listprimes = [(0.99568208890141241+6.5588503358471708e-16j), (1.437542956257241+1.1171619185290638e-15j), (5.3360211094101467e-17-8.8817841970012523e-16j), (-1.4375429562572415-4.9960036108132044e-16j), (-0.99568208890141241-6.8061787699818052e-16j),(-0.3513816866267539-1.1102230246251565e-15j), (-2.207366376866138e-17+8.8817841970012523e-16j), (0.3513816866267539+4.7878367936959876e-16j), (0.99568208890141241+6.5588503358471708e-16j)]#finds the actual values of f'(x) at each x_j nodefxprimelist=[]for i in range(0,9):    x=i*2*math.pi/8    fxprimelist.append(math.cos(x)*cmath.exp(math.sin(x)))#calculates difference between each f'(x) and P8'(x) at each x_j nodeerrorlist = []for i in range(0,9):    errorlist.append(fxprimelist[i]-primes[i])      #calculates error using errorlist from aboveerror=numpy.linalg.norm(errorlist,2)